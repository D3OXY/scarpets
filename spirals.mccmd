/script run 

__command() -> null;


global_settings = m(
						l( 'show_pos' , true ),
						l( 'paste_with_air' , false ),
						l( 'axis' , 'y' ),
						l( 'replace_block' , false ),
						l( 'rotate' , false ), 
						l( 'slope_mode', false ),
						l( 'max_template_size', 100 ),
						l( 'preview_enabled', false ), 
						l( 'undo_history_size', 100 ),
						l( 'scheduled_marking', 5), 
					);
global_block_alias = m(
						l( 'water_bucket', 'water' ),
						l( 'lava_bucket', 'lava'),
						l( 'feather', 'air'),
						l( 'ender_eye', 'end_portal'),
						l( 'flint_and_steel', 'nether_portal')
					);

global_history = l();



set_max_template_size(value) -> (
	if( type(value) == 'number' && value > 0, 
		global_settings:'max_template_size' = value;
		print(format(str('b Max tempalte size value set to %s', value) ) ),
		print(format('rb Error: ', 'y Max template size should be a positive number') )
	);
	return('')
);

set_axis(axis) -> (
	if( ( l('x','y','z')~axis ) == null, 
		print(format('rb Error: ', 'y Axis must be one of ', 'yb x, y ', 'y or ', 'yb z'));
		return('')
	);
	global_settings:'axis' = axis;
	if( axis == 'x',
		__get_step(circle, perimeter, advance_step, i) ->(
			circle_pos = circle:(i%perimeter);
			step = l(i * advance_step, circle_pos:0, circle_pos:1) ;
		),
		axis == 'y',
		__get_step(circle, perimeter, advance_step, i) ->( 
			circle_pos = circle:(i%perimeter);
			step = l(circle_pos:0, i * advance_step, circle_pos:1)
		),
		axis == 'z',
		__get_step(circle, perimeter, advance_step, i) ->(
			circle_pos = circle:(i%perimeter);
			step = l(circle_pos:0, circle_pos:1, i * advance_step) ;
		),
	);
	print(format(str('b Spirals will now generate along the %s axis', axis) ) );
	return('')
);

set_undo_histoy_size(value) -> (
	if( type(value) == 'number' && value > 0, 
		global_settings:'undo_history_size' = value;
		print(format(str('b Max undo value set to %s', value) ) ),
		print(format('rb Error: ', 'y Undo history size should be a positive number') )
	);
	index = length(global_history) - global_settings:'undo_history_size';
	if( index>0 , global_history = slice(global_history, index) );
	return('')
);

toggle_paste_with_air() -> (
	global_settings:'paste_with_air' = !global_settings:'paste_with_air';
	if(global_settings:'paste_with_air',
		print('Template will now be pasted with air'),
		print('Template will now be pasted without air')
	);
	return('')
);

toggle_replace_block() -> (
	global_settings:'replace_block' = !global_settings:'replace_block';
	if(global_settings:'replace_block',
		
		print( format('b Spiral will now only replce block in your offhand.\n',
			'g Hold bucket for liquids, feather for air, ender eye for end portal, and flint and steel for nether portal.') );
		__set_block(pos, material, replace_block) -> if(block(pos) == replace_block, __set_and_save(pos, material) ),
		
		print(format( 'b Spiral will paste completly, replacing whatever is there.') );
		__set_block(pos, material, replace_block) -> __set_and_save(pos, material)
	);
	return('')
);

toggle_slope_mode() -> (
	global_settings:'slope_mode' = !global_settings:'slope_mode';
	if(global_settings:'slope_mode',
		print(format('b Second argument of spiral commands is now slope (in blocks)') ),
		print(format('b Second argument of spiral commands is now pitch(separation between revolutions)') )
	);
	return('')
);


__make_toggle_setting(parameter, hover) -> (
	str_list = l(
		str('w * %s: ', parameter), 
		str('^y %s', hover),
	);
	str_list = extend(str_list, __get_button('true', parameter) );
	str_list = extend(str_list, __get_button('false', parameter) );
	print(format(str_list))
);

__get_active_button(value) -> (
	l( str('yb [%s] ', value) )
);

__get_inactive_button(value, parameter) -> (
	l( 
		str('g [%s] ', value),
		str('^gb Click to toggle'),
		str('!/spirals toggle_%s', parameter)
	)
);

__get_button(value, parameter) -> (
	bool_val = if(bool(value), global_settings:parameter, !global_settings:parameter);
	if( bool_val, __get_active_button(value), __get_inactive_button(value, parameter) )
);


__make_value_setting(parameter, hover, options) -> (
	str_list = l(
		str('w * %s: ', parameter), 
		str('^y %s', hover),
	);
	options_list = l();
	map( options, 
			len = length(options_list);
			options_list:len = str('%sb [%s]', if(global_settings:parameter == _, 'y', 'g',), _);
			options_list:(len+1) = '^bg Click to set this value';
			options_list:(len+2) = str('?/spirals set_%s %s', parameter, _) 
	);
	print(format( extend(str_list, options_list) ))
);


settings() -> (
	print(format( 'b Spirals app settings:' ));
	__make_toggle_setting('show_pos', 'Shows markers and outlines selection');
	__make_toggle_setting('paste_with_air', 'Includes air when pasting template');
	__make_toggle_setting('replace_block', 'Spirals will only be generated replacing block in offhand');
	__make_toggle_setting('slope_mode', 'Defines behaviour of second argument in spiral definitions: slope or pitch');
	__make_value_setting('axis', 'Axis along which spirals are generated', l('x', 'y', 'z') );
	__make_value_setting('max_template_size', 'Limits template size to avoid freezing the game if you mess up the selection', l(20, 100, 1200) );
	__make_value_setting('undo_history_size', 'Sets the maximum ammount of actions to undo', l(10, 50, 500) );
	return('')
);




__get_replace_block() -> (
	block = query(player(), 'holds', 'offhand'):0;
	alias = global_block_alias:block;
	if(alias==null, block, alias)
);

__get_step(circle, perimeter, advance_step, i) ->( 
	circle_pos = circle:(i%perimeter);
	step = l(circle_pos:0, i * advance_step, circle_pos:1) ;
);

__set_and_save(pos, material) -> ( 
	global_this_story:length(global_this_story) = l(pos, block(pos));
	set(pos , material);
);

__set_block(pos, material, replace_block) -> __set_and_save(pos, material);



_circle(radius, material) -> (
	circ = __make_circle(radius);
	c = pos(player());
	for(circ, 
		set(c + l(_:0, 0, _:1), material); 
		create_marker(str(_i), c + l(_:0, 0, _:1))
	);	
);

__get_center() -> (
	if(global_positions:2 == null,
		pos(player()),
		global_positions:2
	)
);

__put_into_history(story) -> (
	global_history:length(global_history) = story;
	if(length(global_history) > global_settings:'undo_history_size',
		delete(global_history, 0)
	);
);

__undo(index) -> (
	
	for(range(length(global_history:index)-1, -1, -1),
		set(global_history:index:_:0, global_history:index:_:1);
	);
	
	
	delete(global_history, index);
);

go_to_story(num) -> (

	
	if( type(num) != 'number' || num <= 0, 
		print(format('rb Error: ', 'y Need a positive number of steps to go to'));
		return('')
	);

	index = length(global_history)-num;
	if(index<0, 
		print(format('rb Error: ', str('y You only have %d actions available to undo', length(global_history) ) ));
		return('')
	);
	
	__undo(index);
	print(str('Undid what you did %s actions ago', num ));	
);

undo(num) -> (
	
	if( type(num) != 'number' || num <= 0, 
		print(format('rb Error: ', 'y Need a positive number of steps to undo'));
		return('')
	);

	index = length(global_history)-num;
	if(index<0, 
		print(format('rb Error: ', str('y You only have %d actions to undo available', length(global_history) ) ));
		return('')
	);
	
	loop(num, __undo(length(global_history)-1) );
	print(str('Undid the last %d actions', num) );
);

history_size() -> print(length(global_history));

__rotated90(list_to_rotate) -> ( 
	map(list_to_rotate, l(_:1, -_:0))
);

extend(list, extension) -> (
	len = length(list);
	for(extension, list:(len+_i) = _);
	return(list)
);

__make_circle(radius) -> (
	z_function(x, outer(radius)) -> round(sqrt(radius * radius - x*x));
	range_val = radius * cos(45); 
	x_range = range(-range_val, range_val);
	
	quarter1 = map(x_range, l(_, z_function(_)) ); 
	half = extend(quarter1, __rotated90(quarter1)); 
	extend(half,__rotated90(__rotated90(half))); 
);




__draw_spiral(circle, center, pitch, size, material) -> (
	l(cx, cy, cz) = center; 
	perimeter = length(circle); 
	
	replace_block = __get_replace_block();
	advance_step = if(global_settings:'slope_mode', pitch, pitch/perimeter); 
	global_this_story = l();
	
	loop(floor( size / advance_step), 
		this_step =  __get_step(circle, perimeter, advance_step, _);
		__set_block(center + this_step , material, replace_block);
	);
	__put_into_history(global_this_story); 
	print(str('Set %d blocks', length(global_this_story) ));
);

spiral(radius, pitch, size, material) -> (
	center = __get_center(); 
	circle = __make_circle(radius);
	__draw_spiral(circle, center, pitch, size, material);
);

antispiral(radius, pitch, size, material) -> (
	center = __get_center(); 
	circle = __make_circle(radius);
	circle = map(range(length(circle)-1, -1, -1), circle:_); 
	__draw_spiral(circle, center, pitch, size, material);

);

multispiral(radius, pitch, size, ammount, material) -> (
	center = __get_center(); 
	circle = __make_circle(radius);
	perimeter = length(circle); 
	loop(ammount,
		jump = floor(_ * perimeter/ammount); 
		this_circ = extend(slice(circle, jump), slice(circle, 0, jump) ); 
		__draw_spiral(this_circ, center, pitch, size, material);
	);
);

antimultispiral(radius, pitch, size, ammount, material) -> (
	center = __get_center(); 
	circle = __make_circle(radius);
	circle = map(range(length(circle)-1, -1, -1), circle:_); 
	perimeter = length(circle); 
	loop(ammount,
		jump = floor(_ * perimeter/ammount); 
		this_circ = extend(slice(circle, jump), slice(circle, 0, jump) ); 
		__draw_spiral(this_circ, center, pitch, size, material);
	);
);





__make_template() -> (
	global_template = l();
	origin = map(range(3), min(global_positions:0:_, global_positions:1:_)); 
	volume(
		global_positions:0:0, global_positions:0:1, global_positions:0:2,
		global_positions:1:0, global_positions:1:1, global_positions:1:2,
		if(global_settings:'paste_with_air',
			global_template:length(global_template) = l(pos(_)-origin, _),
			if(!air(_), global_template:length(global_template) = l(pos(_)-origin, _) ) 
		);
	);
	
	if(length(global_template) > global_settings:'max_template_size',
		print( format(
			'buy Warning',
			'y : ',
			'w Template is too big. Your tried to paste ', 
			str('by %d ', length(global_template)),
			str('w blocks %s, but max size is ', if(global_settings:'paste_with_air', '(counting air)', '(not counting air)') ),
			str('by %d', global_settings:'max_template_size' ),
			'w .\nTry increasing it with ',
			'b [this] ', '^t Click here!', '?/spirals set_max_template_size 200',
			'w command.'
		) );
		true, 
		false 
	)
);


__clone_template(pos, replace_block) -> (
	for(global_template, __set_block(pos + _:0, _:1, replace_block) );
);


__draw_spiral_from_template(circle, center, pitch, size) -> (
	perimeter = length(circle); 
	
	if(__make_template(), return() ); 
	offset = map(global_positions:0 - global_positions:1, abs(_)); 
	advance_step = if(global_settings:'slope_mode', pitch, pitch/perimeter); 
	
	replace_block = __get_replace_block();
	global_this_story = l();
	
	loop(floor( size / advance_step), 
		this_step =  __get_step(circle, perimeter, advance_step, _);
		__clone_template( center + this_step, replace_block);
	);
	
	__put_into_history(global_this_story); 
	print(str('Set %d blocks', length(global_this_story) ));

);

spiral_template(radius, pitch, size) -> (
	center = __get_center(); 
	circle = __make_circle(radius);
	__draw_spiral_from_template(circle, center, pitch, size);
);

antispiral_template(radius, pitch, size) -> (
	center = __get_center(); 
	circle = __make_circle(radius);
	circle = map(range(length(circle)-1, -1, -1), circle:_); 
	__draw_spiral_from_template(circle, center, pitch, size);
);

multispiral_template(radius, pitch, size, ammount) -> (
	center = __get_center(); 
	circle = __make_circle(radius);
	perimeter = length(circle); 
	loop(ammount,
		jump = floor(_ * perimeter/ammount); 
		this_circ = extend(slice(circle, jump), slice(circle, 0, jump) );
		__draw_spiral_from_template(this_circ, center, pitch, size);
	);
);

antimultispiral_template(radius, pitch, size, ammount) -> (
	center = __get_center(); 
	circle = __make_circle(radius);
	circle = map(range(length(circle)-1, -1, -1), circle:_); 
	perimeter = length(circle); 
	loop(ammount,
		jump = floor(_ * perimeter/ammount); 
		this_circ = extend(slice(circle, jump), slice(circle, 0, jump) );
		__draw_spiral_from_template(this_circ, center, pitch, size);
	);
);




__mark(i, position) -> (
 	colours = l('red', 'lime', 'light_blue'); 
	e = create_marker('pos' + i, position + l(0.5, 0.5, 0.5), colours:(i-1) + '_concrete'); 
	run(str( 
		'data merge entity %s {Glowing:1b, Fire:32767s, Marker:1b}', query(e, 'uuid') 
		));
	put(global_armor_stands, i-1, query(e, 'id')); 
);

__remove_mark(i) -> (
	e = entity_id(global_armor_stands:(i));
 	if(e != null, modify(e, 'remove'));
);


set_pos(i) -> (
	try( 
 		if( !reduce(range(1,4), _a + (_==i), 0),
			throw();
		),
		print(format('rb Error: ', 'y Input must be either 1, 2 or 3 for position to set. You input ' + i) );
		return()
	);
	
	tha_block = query(player(), 'trace');
	if(tha_block!=null,
		tha_pos = pos(tha_block),
		tha_pos = map(pos(player()), round(_))
	);
	global_positions:(i-1) = tha_pos; 
	if(all(slice(global_positions, 0, 2), _!=null), global_all_set = true); 
	
	print(str('Set your position %d to ',i) + tha_pos);

	if(global_settings:'show_pos', 
		__remove_mark(i-1); 
		__mark(i, tha_pos);
	);

);


get_pos() -> (
	for(global_positions, 
 		print(str('Position %d is %s', 
				_i+1, if(_==null, 'not set', _)));
 	)
);


toggle_show_pos() ->(
	global_settings:'show_pos' = !global_settings:'show_pos'; 
	if(global_settings:'show_pos',
		( 
			for(global_positions, 
				if(_!=null, __mark( (_i+1) , _) );
			);
			print('Positions shown');
		),
		
		( 
			for(global_armor_stands, 
				__remove_mark(_i);
			);
			print('Positions hidden');
		);
	);
);


reset_positions() -> (
	loop(3, 
		__remove_mark(_);
	);
	global_positions = l(null, null, null); 
	global_all_set = false;
	global_armor_stands = l(null, null, null);
);
reset_positions();


__on_player_clicks_block(player, block, face) -> (
	if(query(player(), 'holds'):0 == 'golden_sword',
		set_pos(1);
	);
);


__on_player_uses_item(player, item_tuple, hand) -> (
	if(query(player(), 'holds'):0 == 'golden_sword',
		if(query(player(), 'sneaking'),
			set_pos(3),
			set_pos(2)
		);
	);
);


__on_tick() -> (

	if( global_all_set && global_settings:'show_pos' &&	tick_time()%20 == 0,			
		min_pos = map(range(3), min(global_positions:0:_, global_positions:1:_));
		max_pos = map(range(3), max(global_positions:0:_, global_positions:1:_));
		particle_rect('end_rod', min_pos, max_pos + l(1, 1, 1))
	);
);

__on_tick_ender() -> (

	if( global_all_set && global_settings:'show_pos' &&	tick_time()%20 == 0,			
		min_pos = map(range(3), min(global_positions:0:_, global_positions:1:_));
		max_pos = map(range(3), max(global_positions:0:_, global_positions:1:_));
		particle_rect('end_rod', min_pos, max_pos + l(1, 1, 1))
	);
);

__on_tick_nether() -> (

	if( global_all_set && global_settings:'show_pos' &&	tick_time()%20 == 0,			
		min_pos = map(range(3), min(global_positions:0:_, global_positions:1:_));
		max_pos = map(range(3), max(global_positions:0:_, global_positions:1:_));
		particle_rect('end_rod', min_pos, max_pos + l(1, 1, 1))
	);
);
